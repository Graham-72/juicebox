<?php


/**
 * @file
 * Provides Drupal integration with the Juicebox library.
 */


/**
 * Implements hook_menu().
 */
function juicebox_menu() {
  $items = array();
  // Add menu item that produces the "config.xml" data that is linked to a
  // specific view or entity field.
  $items['juicebox/xml/%'] = array(
    'title' => 'Juicebox XML from view',
    'description' => 'Deliver configuration XML for a Juicebox gallery.',
    'page callback' => 'juicebox_page_xml',
    'page arguments' => array(2),
    // For efficiency we'll check access in parallel to other logic in the
    // callback function, so we don't limit any access here.
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}


/**
 * Implements hook_theme().
 */
function juicebox_theme() {
  return array(
    // Theme hook to generate embed markup for a Juicebox gallery.
    'juicebox_embed_markup' => array(
      'variables' => array('gallery_id' => '', 'gallery_xml_path' => '', 'settings' => array(), 'data' => array()),
      'path' => drupal_get_path('module', 'juicebox') . '/themes',
      'file' => 'juicebox.theme.inc',
    ),
  );
}


/**
 * Implements hook_libraries_info().
 */
function juicebox_libraries_info() {
  $libraries['juicebox'] = array(
    'name' => 'Juicebox',
    'vendor url' => 'http://www.juicebox.net/',
    'download url' => 'http://www.juicebox.net/download/',
    'version arguments' => array(
      'file' => 'juicebox.js',
      'pattern' => '/Juicebox.([a-zA-Z]+[0-9\.\ -]+)/',
      'lines' => 5,
    ),
    'files' => array(
      // Note that we do not want the Juicebox library javascript to be
      // aggregated by Drupal (set preprocess option = FALSE). This is because
      // some supporting library CSS files must be at a specific location
      // RELATIVE to to the main js file. Aggregation breaks this.
      'js' => array('juicebox.js' => array('preprocess' => FALSE)),
    ),
    'callbacks' => array(
      'info' => array('juicebox_library_info'),
      'post-detect' => array('juicebox_library_post_detect'),
    ),
  );
  return $libraries;
}


/**
 * Implements hook_views_api().
 */
function juicebox_views_api() {
  return array(
    'api' => 3.0,
  );
}


/**
 * Implements hook_views_plugin().
 */
function juicebox_views_plugins() {
  $path = drupal_get_path('module', 'juicebox');
  $plugins['style']['juicebox'] = array(
    'title' => t('Juicebox Gallery'),
    'help' => t('Display rows as a Juicebox Gallery.'),
    'handler' => 'JuiceboxViewsStylePlugin',
    'path' => $path . '/plugins',
    'uses row plugin' => FALSE,
    'uses fields' => TRUE,
    'uses options' => TRUE,
    'uses grouping' => FALSE,
    'type' => 'normal',
  );
  return $plugins;
}


/**
 * Menu callback: generate Juicebox XML.
 *
 * Note that this callback directly sets page headers and prints the XML result
 * (if one can successfully be rendered).
 *
 * @see juicebox_menu()
 */
function juicebox_page_xml() {
  $args = func_get_args();
  try {
    $class = juicebox_gallery_class($args[0]);
    $juicebox = new $class($args);
    $juicebox->load();
    if (!$juicebox->access()) {
      return MENU_ACCESS_DENIED;
    }
    // Build the Juicebox gallery data.
    $juicebox->build();
    $xml = $juicebox->getXML();
  }
  catch (Exception $e) {
    $message = 'Exception building Juicebox XML: !message in %function (line %line of %file).';
    watchdog_exception('juicebox', $e, $message);
    return MENU_NOT_FOUND;
  } 
  drupal_add_http_header('Content-Type', 'text/xml');
  // Bypass all themeing but still return (don't die) so that
  // drupal_page_footer() is called.
  print($xml);
  return NULL;
}


/**
 * Libraries API Info Callback
 * 
 * Add baseline variables to a Juicebox library array that are not version
 * specific but should always be defined. These values are generic to all
 * Juicebox libraries and may be referenced even when the local library info
 * cannot be loaded or is not used.
 * 
 * @see juicebox_libraries_info().
 */
function juicebox_library_info(&$library) {
  $library['disallowed_conf'] = array();
  $library['compatible_mimetypes'] = array('image/gif', 'image/jpeg', 'image/png');
}


/**
 * Libraries API Post-Detect Callback
 * 
 * Add detailed variables to a Juicebox library array after the version info can
 * be detected.
 * 
 * @see juicebox_libraries_info().
 */
function juicebox_library_post_detect(&$library) {
  $pro = FALSE;
  $disallowed_conf = array();
  if (!empty($library['version'])) {
    // Check if this is a Pro version.
    if (stripos($library['version'], "Pro") !== FALSE) {
      $pro = TRUE;
    }
    // Get numeric part of the version statement.
    $version_number = 0;
    $matches = array();
    preg_match("/[0-9\.]+[^\.]$/u", $library['version'], $matches);
    if (!empty($matches[0])) {
      $version_number = $matches[0];
    }
    // Some options are not available as LITE options before v1.3.
    if (!$pro && version_compare($version_number, '1.3', '<')) {
      $disallowed_conf = array_merge($disallowed_conf, array('jlib_textColor', 'jlib_thumbFrameColor', 'jlib_useFullscreenExpand', 'jlib_useThumbDots'));
    }
  }
  $library['pro'] = $pro;
  $library['disallowed_conf'] = $disallowed_conf;
}


/**
 * Helper to detect if a given file item is not compatible with Juicebox, and
 * define an alternative file to display if so.
 *
 * @param array $item
 *   An associative array containing all file entity properties for the file to
 *   check.
 * @param array $library
 *   An associative array containing the library information that corresponds
 *   to the Juicebox javascript library that will be used for the display.
 * @return string
 *   If an incompatible file is detected an alternative image path is returned,
 *   otherwise returns NULL.
 */
function _juicebox_incompatible_file_alternative($item, $library) {
  if (!empty($library['compatible_mimetypes']) && !in_array($item['filemime'], $library['compatible_mimetypes'])) {
    $icon_dir = drupal_get_path('module', 'juicebox') . '/images/mimetypes';
    $icon_path = file_icon_path(file_load($item['fid']), $icon_dir);
    if ($icon_path) {
      return url($icon_path);
    }
    return url($icon_dir . '/image-x-generic.png');
  }
  return NULL;
}


/**
 * Form validation callback: validate width/height inputs.
 *
 * @see _juicebox_common_form_elements()
 */
function _juicebox_element_validate_dimension($element, &$form_state, $form) {
  if (!preg_match('/^[0-9]+?(%|px|em|in|cm|mm|ex|pt|pc)$/u', $element['#value'])) {
    form_error($element, t('Please ensure that you width and height values are entered in a standard numeric format (such as <strong>100%</strong> or <strong>300px</strong>).'));
  }
}


/**
 * Form validation callback: validate Juicebox configuration options.
 *
 * @see _juicebox_common_form_elements()
 */
function _juicebox_element_validate_config($element, &$form_state, $form) {
  // We are looking for input in the format of: optionName="optionValue".
  // The check here is not too strict, it is just meant to catch general
  // formatting issues.
  $custom_options = explode("\n", $element['#value']);
  foreach ($custom_options as $key => $option) {
    $option = trim($option);
    $line_number = $key + 1;
    if (!empty($option) && !preg_match('/^[A-Za-z0-9]+?="[^"]+?"$/u', $option)) {
      form_error($element, t('One of your manual configuration options appears to be formatted incorrectly. Please check line @line of this field and ensure that you are using the format <strong>optionName="optionValue"</strong> and that all spaces have been removed.', array('@line' => $line_number)));
    }
  }
}


/**
 * Implements hook_field_formatter_info().
 *
 * Add juicebox_formatter formatter.
 */
function juicebox_field_formatter_info() {
  // Get the base settings.
  $class = juicebox_gallery_class('field');
  $base_settings = call_user_func($class . '::confBaseOptions');
  $formatters = array(
    'juicebox_formatter' => array(
      'label' => t('Juicebox Gallery'),
      'field types' => array('image', 'file'),
      'settings' => array_merge($base_settings, array(
        'image_style' => '',
        'thumb_style' => 'thumbnail',
        'caption_source' => 'alt',
        'title_source' => 'title',
      )),
    ),
  );
  return $formatters;
}


/**
 * Implements hook_field_formatter_settings_form().
 */
function juicebox_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $form = array();
  // Get available title and caption sources.
  $text_sources = _juicebox_field_formatter_get_text_sources($instance);
  // Get available image style presets
  $presets = image_style_options(FALSE);
  $settings = $instance['display'][$view_mode]['settings'];
  // Get the common form elements.
  $class = juicebox_gallery_class('field');
  $form = call_user_func($class . '::confBaseForm', $form, $settings);
  // Add the field-formatter-specific elements.
  $form['image_style'] = array(
    '#type' => 'select',
    '#title' => t('Main Image Style'),
    '#default_value' => $settings['image_style'],
    '#description' => t('The style formatter for the main image.'),
    '#options' => $presets,
    '#empty_option' => t('None (original image)'),
  );
  $form['thumb_style'] = array(
    '#type' => 'select',
    '#title' => t('Thumbnail Style'),
    '#default_value' => $settings['thumb_style'],
    '#description' => t('The style formatter for the thumbnail.'),
    '#options' => $presets,
    '#empty_option' => t('None (original image)'),
  );
  $form['caption_source'] = array(
    '#type' => 'select',
    '#title' => t('Caption Source'),
    '#default_value' => $settings['caption_source'],
    '#description' => t('The image value that should be used for the caption.'),
    '#options' => $text_sources,
    '#empty_option' => t('No caption'),
  );
  $form['title_source'] = array(
    '#type' => 'select',
    '#title' => t('Title Source'),
    '#default_value' => $settings['title_source'],
    '#description' => t('The image value that should be used for the title.'),
    '#options' => $text_sources,
    '#empty_option' => t('No title'),
  );
  return $form;
}


/**
 * Implements hook_field_formatter_view().
 *
 * This is where the Juicebox embed code is built for the field formatter.
 */
function juicebox_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  // If there are no images, don't do anything else.
  if (empty($items)) {
    return;
  }
  $field_name = $instance['field_name'];
  $entity_type_info = entity_get_info($entity_type);
  $entity_id = $entity->{$entity_type_info['entity keys']['id']};
  // We need to get the display name to pass as part of our XML path. Though
  // we have access to the actaul $display array, it does not look like we
  // have access to the actaul display NAME in this scope. We do have access to
  // a list of ALL displays in $instanace though, so iterate though them to
  // find a match to the settings in $display.
  $display_name = 'default';
  foreach ($instance['display'] as $display_key => $display_data) {
    if ($display['settings'] == $display_data['settings']) {
      $display_name = $display_key;
    }
  }
  // Generate xml path details.
  $xml_path = 'juicebox/xml/field/' . $entity_type . '/' . $entity_id . '/' . $field_name . '/' . $display_name;
  $xml_args = explode('/', $xml_path);
  
  // Instantiate and build the Juicebox gallery.
  try {
    $class = juicebox_gallery_class('field');
    $juicebox = new $class($xml_args, $items, $display['settings']);
    // For some reason core does not test field access until AFTER this hook.
    // Because of this we run our own (duplicate) field access test here to
    // prevent unneeded logic from running if the output will be hidden. Note
    // that by this point we know that entity access is already granted.
    $juicebox->entityAccess = TRUE;
    if ($juicebox->access()) {
      // Build the gallery.
      $juicebox->build();
      // Get the full XML url.
      $xml_query = array_merge(array('checksum' => $juicebox->galleryChecksum), drupal_get_query_parameters());
      $xml_url = url($xml_path, array('query' => $xml_query));
      // Load the juicebox javascript library and gallery-specific javascript.
      libraries_load('juicebox');
      drupal_add_js($juicebox->getJavascript($xml_url), 'inline');
      $element[0] = array('#markup' => $juicebox->getEmbed());
    }
  }
  catch (Exception $e) {
    $message = 'Exception building Juicebox embed code: !message in %function (line %line of %file).';
    watchdog_exception('juicebox', $e, $message);
  }
  return $element;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function juicebox_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $settings_display = array();
  // Image style setting.
  if (!empty($settings['image_style'])) {
    $style = $settings['image_style'];
  }
  else {
    $style = t('Original Image');
  }
  $settings_display[] = t("Image style: @style", array('@style' => $style));
  // Thumb style setting.
  if (!empty($settings['thumb_style'])) {
    $style = $settings['thumb_style'];
  }
  else {
    $style = t('Original Image');
  }
  $settings_display[] = t("Thumbnail style: @style", array('@style' => $style));
  // Define display options for caption and title source.
  $text_sources = _juicebox_field_formatter_get_text_sources($instance);
  // Caption source setting.
  if (!empty($text_sources[$settings['caption_source']])) {
    $source = $text_sources[$settings['caption_source']];
  }
  else {
    $source = t('None');
  }
  $settings_display[] = t("Caption source: @source", array('@source' => $source));
  // Title source setting.
  if (!empty($text_sources[$settings['title_source']])) {
    $source = $text_sources[$settings['title_source']];
  }
  else {
    $source = t('None');
  }
  $settings_display[] = t("Title source: @source", array('@source' => $source));
  // Add-in a note about the additional fieldsets.
  $settings_display[] = t("Additional Juicebox library configuration options may also be set.");
  $summary = implode('<br />', $settings_display);
  return $summary;
}


/**
 * Utility to fetch the title and caption source options for field-based
 * galleries (primarily for File Entity and Media module support).
 *
 * @param array $instance
 *   An associative array containing the Drupal field instance information for
 *   a Juicebox field.
 * @return array
 *   An associative array representing the key => label pairs for each title and
 *   caption source option. Each key will match a keyed value on the image
 *   source array when the gallery is built.
 */
function _juicebox_field_formatter_get_text_sources($instance) {
  // If this is a standard image field, using the image widget, we can use core
  // image "alt" and "title" values if they are active.
  if (!empty($instance['widget']['module']) && $instance['widget']['module'] == 'image') {
    if (!empty($instance['settings']['alt_field'])) {
      $text_source_options['alt'] = t('Image - Alt text (processed by fallback text format)');
    }
    if (!empty($instance['settings']['title_field'])) {
      $text_source_options['title'] = t('Image - Title text (processed by fallback text format)');
    }
  }
  // If file entity is installed we can use fields attached to the "image" file
  // entity.
  if (module_exists('file_entity')) {
    // Get the fields that are available on the image file type.
    $image_fields = field_info_instances('file', 'image');
    foreach ($image_fields as $image_field_name => $image_field) {
      // Only text-based fields should be options.
      if (!empty($image_field['widget']['module']) && $image_field['widget']['module'] == 'text') {
        $text_source_options[$image_field_name] = t('File Entity Image - @label', array('@label' => $image_field['label']));
      }
    }
  }
  return $text_source_options;
}


/**
 * Utility to fetch a field value from an entity field (primarily for Media
 * module support).
 *
 * @param int $fid
 *   The id of a file that can be represented as a file entity. This id will
 *   match the file entity id.
 * @param string $field_name
 *   The name of the field to fetch from the file entity.
 * @return mixed
 *   The safe value for the requested field. For multiple-value fields only the
 *   first value will be returned. Returns NULL if no value can be found.
 */
function _juicebox_get_field_value_from_file_entity($fid, $field_name) {
  // We depend on the entity cache for performance when loading the file entity.
  // If the passed fid does in fact represent a file entity then there
  // is a very good chance it's been loaded already by the time this function is
  // called.
  $file_entity = entity_load('file', array($fid));
  if (!empty($file_entity[$fid])) {
    $field = field_get_items('file', $file_entity[$fid], $field_name);
    if (!empty($field[0]['safe_value'])) {
      return $field[0]['safe_value'];
    }
  }
  return NULL;
}


/**
 * Form pre-render callback: visually render fieldsets without affecting
 * tree-based variable storage.
 * 
 * This technique/code is taken almost directly from the Views module in
 * views_ui_pre_render_add_fieldset_markup()
 */
function juicebox_form_pre_render_fieldsets($form) {
  foreach (element_children($form) as $key) {
    $element = $form[$key];
    // In our form builder functions, we added an arbitrary #jb_fieldset
    // property to any element that belongs in a fieldset. If this form element
    // has that property, move it into its fieldset.
    if (isset($element['#jb_fieldset']) && isset($form[$element['#jb_fieldset']])) {
      $form[$element['#jb_fieldset']][$key] = $element;
      // Remove the original element this duplicates.
      unset($form[$key]);
    }
  }
  return $form;
}


function juicebox_gallery_class($type) {
  $class = '';
  switch ($type) {
    case 'field':
      $class = 'JuiceboxGalleryDrupalField';
      break;
    case 'view':
      $class = 'JuiceboxGalleryDrupalViewsStyle';
      break;
  }
  // Allow other modules do alter the class name.
  drupal_alter('juicebox_gallery_class', $class, $type);
  if (!empty($class)) {
    return $class;
  }
  return NULL;
}