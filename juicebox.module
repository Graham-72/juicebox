<?php


/**
 * @file
 * Provides Drupal integration with the Juicebox library. This file contains
 * the relevant Drupal hook implementations and callbacks.
 */


/**
 * Implements hook_menu().
 */
function juicebox_menu() {
  $items = array();
  // Add menu item that produces the "config.xml" data that is linked to a
  // specific gallery.
  $items['juicebox/xml/%'] = array(
    'title' => 'Juicebox XML from view',
    'description' => 'Deliver configuration XML for a Juicebox gallery.',
    'page callback' => 'juicebox_page_xml',
    'page arguments' => array(2),
    // For efficiency we'll check access in parallel to other logic in the
    // callback function, so we don't limit any access here.
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/media/juicebox'] = array(
    'title' => 'Juicebox',
    'description' => 'Adjust global Juicebox settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('juicebox_admin_settings'),
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}


/**
 * Implements hook_theme().
 */
function juicebox_theme() {
  return array(
    // Theme hook to generate embed markup for a Juicebox gallery.
    'juicebox_embed_markup' => array(
      'variables' => array('gallery' => NULL, 'settings' => array()),
      'path' => drupal_get_path('module', 'juicebox') . '/themes',
      'file' => 'juicebox.theme.inc',
    ),
    // Theme hook to generate info/debug information for a Juicebox gallery.
    'juicebox_debug_markup' => array(
      'variables' => array('gallery' => NULL, 'xml' => array(), 'settings' => array()),
      'path' => drupal_get_path('module', 'juicebox') . '/themes',
      'file' => 'juicebox.theme.inc',
    ),
    // Theme hook to generate toggle links between gallery and debug info.
    'juicebox_toggle_markup' => array(
      'variables' => array('gallery' => NULL, 'settings' => array(), 'debug' => FALSE),
      'path' => drupal_get_path('module', 'juicebox') . '/themes',
      'file' => 'juicebox.theme.inc',
    ),
  );
}


/**
 * Implements hook_libraries_info().
 */
function juicebox_libraries_info() {
  $libraries['juicebox'] = array(
    'name' => 'Juicebox',
    'vendor url' => 'http://www.juicebox.net/',
    'download url' => 'http://www.juicebox.net/download/',
    'version arguments' => array(
      'file' => 'juicebox.js',
      'pattern' => '/Juicebox.([a-zA-Z]+[0-9\.\ -]+)/',
      'lines' => 5,
    ),
    'files' => array(
      // Note that we do not want the Juicebox library javascript to be
      // aggregated by Drupal (set preprocess option = FALSE). This is because
      // some supporting library CSS files must be at a specific location
      // RELATIVE to to the main js file. Aggregation breaks this.
      'js' => array('juicebox.js' => array('preprocess' => FALSE, 'scope' => variable_get('juicebox_js_scope', 'header'))),
    ),
    'callbacks' => array(
      'info' => array('juicebox_library_info'),
      'post-detect' => array('juicebox_library_post_detect'),
    ),
  );
  return $libraries;
}


/**
 * Implements hook_views_api().
 */
function juicebox_views_api() {
  return array(
    'api' => 3.0,
  );
}


/**
 * Implements hook_views_plugin().
 */
function juicebox_views_plugins() {
  $path = drupal_get_path('module', 'juicebox');
  $plugins['style']['juicebox'] = array(
    'title' => t('Juicebox Gallery'),
    'help' => t('Display rows as a Juicebox Gallery.'),
    'handler' => 'JuiceboxViewsStylePlugin',
    'path' => $path . '/plugins',
    'uses row plugin' => FALSE,
    'uses fields' => TRUE,
    'uses options' => TRUE,
    'uses grouping' => FALSE,
    'type' => 'normal',
  );
  return $plugins;
}


/**
 * Instantiate a Juicebox connector object along with its dependencies.
 * 
 * @param array $xml_path_args
 *   An indexed array of XML path arguments that describe this gallery (and
 *   make up its XML URL). This information uniquely identifies the gallery and
 *   contains all the descriptive data needed to (re)build it.
 * @param mixed $data
 *   (Optional) Loaded Drupal data that the gallery can be built from. When
 *   the embed code is being generated for a Drupal display formatter this data
 *   will typically be available already. However when building the XML this
 *   will be NULL, and we will need to be load it ourselves (based on the XML
 *   args) after the objects are instantiated.
 * @return object
 *   A new Juicebox plugin object that contains an empty Juicebox gallery
 *   object.
 */
function juicebox($xml_path_args, $data = NULL, $xml = FALSE) {
  // The XML args may be passed as a full set of path args. If so we can
  // drop some args that are only used for menu routing.
  if ($xml_path_args[0] == 'juicebox' && $xml_path_args[1] == 'xml') {
    $xml_path_args = array_slice($xml_path_args, 2);
  }
  // Calculate the gallery ID.
  $id = '';
  foreach ($xml_path_args as $arg) {
    $id .= $arg . '-';
  }
  $id = trim($id, '- ');
  // The type should match the first argument.
  $type = $xml_path_args[0];
  // Get the library data. We do this early (before instantiating) as the lib
  // details should be allowed to impact which classes are used.
  $library = juicebox_library_detect();
  // Calculate the connector classes that are supported directly by this module.
  $classes = array('connector_plugin' => '', 'gallery' => 'JuiceboxGallery');
  switch ($type) {
    case 'field':
      $classes['connector_plugin'] = 'JuiceboxConnectorField';
      break;
    case 'view':
      $classes['connector_plugin'] = 'JuiceboxConnectorViewsStyle';
      break;
  }
  // Allow other modules to alter the classes that will be used.
  $context = array('data' => $data, 'library' => $library);
  drupal_alter('juicebox_classes', $classes, $xml_path_args, $context);
  // Instantiate the Juicebox gallery object.
  $gallery = new $classes['gallery']($id);
  // Instantiate the Juicebox connector object.
  $juicebox = new $classes['connector_plugin']($xml_path_args, $data, $gallery, $library);
  if (is_object($juicebox)) {
    return $juicebox;
  }
  return NULL;
}


/**
 * Get/detect the details of a Juicebox javascript library without loading it.
 * 
 * This is essentially a wrapper for libraries_detect() with some caching added.
 * It also allows library info to be fetched independently from the currently
 * loaded version if needed (e.g. to accomodate XML requests that don't come
 * from this site).
 * 
 * @param boolean $force_local
 *   Whether-or-not to force detection of the LOCALLY installed Juicebox library
 *   details. If FALSE Libraries API detection may be bypased if library version
 *   details can be detected through the URL.
 * @param boolean $reset
 *   Whether-or-not to bypass and reset any caching information.
 * @return array
 *   An associative array of the library information.
 */
function juicebox_library_detect($force_local = FALSE, $reset = FALSE) {
  // We use our own static cache for this. Libraries API detection has a static
  // cache, but as we may be bypassing full local detection in certain
  // situations, we can't always use it.
  $library = &drupal_static(__FUNCTION__, array());
  if (!$library || $reset) {
    // See if we have been passed version details in the URL. If so we bypass
    // local detection and build our own libraries array.
    $query = drupal_get_query_parameters();
    if (!empty($query['jb-version']) && !$force_local) {
      juicebox_library_info($library);
      $version_number = check_plain($query['jb-version']);
      if (!empty($query['jb-pro'])) {
        $library['pro'] = TRUE;
        $version = 'Pro';
      }
      else {
        $version = 'Lite';
      }
      $library['version'] = $version . ' ' . $version_number;
      juicebox_library_post_detect($library);
    }
    // Otherwise we just use the Libraries API to detect the local lib.
    else {
      // We maintain our own DB cache here because libraries_detect() does not
      // have one. libaries_load() has one, but we don't want to be actually
      // loading the library here.
      $library = cache_get('juicebox_local_library', 'cache');
      if ($library && !$reset) {
        $library = $library->data;
      }
      else {
        $library = libraries_detect('juicebox');
        cache_set('juicebox_local_library', $library, 'cache');
      }
    }
  }
  return $library;
}


/**
 * Menu callback: generate Juicebox XML.
 *
 * Note that this callback directly sets page headers and prints the XML result
 * (if one can successfully be rendered).
 *
 * @see juicebox_menu()
 */
function juicebox_page_xml() {
  $args = func_get_args();
  try {
    $juicebox = juicebox($args, NULL, TRUE);
    $juicebox->load();
    if (!$juicebox->access()) {
      return MENU_ACCESS_DENIED;
    }
    // Build the Juicebox gallery data.
    $juicebox->build();
    $xml = $juicebox->gallery->getXML();
  }
  catch (Exception $e) {
    $message = 'Exception building Juicebox XML: !message in %function (line %line of %file).';
    watchdog_exception('juicebox', $e, $message);
    return MENU_NOT_FOUND;
  } 
  drupal_add_http_header('Content-Type', 'text/xml');
  // Bypass all themeing but still return (don't die) so that
  // drupal_page_footer() is called.
  print($xml);
  return NULL;
}


/**
 * Libraries API Info Callback
 * 
 * Add baseline variables to a Juicebox library array that are not version
 * specific but should always be defined. These values are generic to all
 * Juicebox libraries and may be referenced even when the local library info
 * cannot be loaded or is not used.
 * 
 * @see juicebox_libraries_info().
 */
function juicebox_library_info(&$library) {
  $library['disallowed_conf'] = array();
  $library['compatible_mimetypes'] = array('image/gif', 'image/jpeg', 'image/png');
}


/**
 * Libraries API Post-Detect Callback
 * 
 * Add detailed variables to a Juicebox library array after the version info can
 * be detected.
 * 
 * @see juicebox_libraries_info().
 */
function juicebox_library_post_detect(&$library) {
  $pro = FALSE;
  $disallowed_conf = array();
  if (!empty($library['version'])) {
    // Check if this is a Pro version.
    if (stripos($library['version'], "Pro") !== FALSE) {
      $pro = TRUE;
    }
    // Get numeric part of the version statement.
    $version_number = 0;
    $matches = array();
    preg_match("/[0-9\.]+[^\.]$/u", $library['version'], $matches);
    if (!empty($matches[0])) {
      $version_number = $matches[0];
    }
    // Some options are not available as LITE options before v1.3.
    if (!$pro && version_compare($version_number, '1.3', '<')) {
      $disallowed_conf = array_merge($disallowed_conf, array('jlib_textColor', 'jlib_thumbFrameColor', 'jlib_useFullscreenExpand', 'jlib_useThumbDots'));
    }
  }
  $library['pro'] = $pro;
  $library['disallowed_conf'] = $disallowed_conf;
}


/**
 * Form validation callback: validate width/height inputs.
 */
function juicebox_element_validate_dimension($element, &$form_state, $form) {
  if (!preg_match('/^[0-9]+?(%|px|em|in|cm|mm|ex|pt|pc)$/u', $element['#value'])) {
    form_error($element, t('Please ensure that you width and height values are entered in a standard numeric format (such as <strong>100%</strong> or <strong>300px</strong>).'));
  }
}


/**
 * Form validation callback: validate Juicebox configuration options.
 */
function juicebox_element_validate_config($element, &$form_state, $form) {
  // We are looking for input in the format of: optionName="optionValue".
  // The check here is not too strict, it is just meant to catch general
  // formatting issues.
  $custom_options = explode("\n", $element['#value']);
  foreach ($custom_options as $key => $option) {
    $option = trim($option);
    $line_number = $key + 1;
    if (!empty($option) && !preg_match('/^[A-Za-z0-9]+?="[^"]+?"$/u', $option)) {
      form_error($element, t('One of your manual configuration options appears to be formatted incorrectly. Please check line @line of this field and ensure that you are using the format <strong>optionName="optionValue"</strong> and that all spaces have been removed.', array('@line' => $line_number)));
    }
  }
}


/**
 * Form pre-render callback: visually render fieldsets without affecting
 * tree-based variable storage.
 * 
 * This technique/code is taken almost directly from the Views module in
 * views_ui_pre_render_add_fieldset_markup()
 */
function juicebox_form_pre_render_fieldsets($form) {
  foreach (element_children($form) as $key) {
    $element = $form[$key];
    // In our form builder functions, we added an arbitrary #jb_fieldset
    // property to any element that belongs in a fieldset. If this form element
    // has that property, move it into its fieldset.
    if (isset($element['#jb_fieldset']) && isset($form[$element['#jb_fieldset']])) {
      $form[$element['#jb_fieldset']][$key] = $element;
      // Remove the original element this duplicates.
      unset($form[$key]);
    }
  }
  return $form;
}


/**
 * Menu callback: global configuration options to control Juicebox behaviour.
 * 
 * @see juicebox_menu()
 */
function juicebox_admin_settings() {
  $form['juicebox_admin_intro'] = array(
    '#markup' => t("Most Juicebox configuration options are specified within each gallery's unique configuration form. The options here are additional global settings for administrative and debugging purposes. Please be sure to clear your site's caches within the !performance settings after making any changes here.", array('!performance' => l(t('performance'), 'admin/config/development/performance'))),
  );
  $form['juicebox_js_scope'] = array(
    '#type' => 'select',
    '#title' => t('Javscript Scope'),
    '#options' => array('header' => t('Header'), 'footer' => t('Footer')),
    '#default_value' => variable_get('juicebox_js_scope', 'header'),
    '#description' => t('The scope in which to add the Juicebox javascript library and all gallery-specific definitions.'),
  );
  $form['juicebox_apply_markup_filter'] = array(
    '#type' => 'checkbox',
    '#title' => t('Filter all title and caption output for compatibility with Juicebox javascript (recommended)'),
    '#default_value' => variable_get('juicebox_apply_markup_filter', TRUE),
    '#description' => t('This option helps ensure title/caption output is syntactically compatible with the Juicebox javascript library by removing block-level tags.'),
  );
  $form['juicebox_show_debug_links'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show links to debug info'),
    '#default_value' => variable_get('juicebox_show_debug_links', FALSE),
    '#description' => t('Show links above each gallery to toggle the display of gallery debugging information.'),
  );
  return system_settings_form($form);
}


/**
 * Implements hook_field_formatter_info().
 *
 * Add juicebox_formatter formatter.
 */
function juicebox_field_formatter_info() {
  // Get the base settings.
  $base_settings = JuiceboxConnector::confBaseOptions();
  $formatters = array(
    'juicebox_formatter' => array(
      'label' => t('Juicebox Gallery'),
      'field types' => array('image', 'file'),
      'settings' => array_merge($base_settings, array(
        'image_style' => '',
        'thumb_style' => 'thumbnail',
        'caption_source' => 'alt',
        'title_source' => 'title',
      )),
    ),
  );
  return $formatters;
}


/**
 * Implements hook_field_formatter_settings_form().
 */
function juicebox_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  // If this formatter is being used outside the context of a normal field
  // display (e.g. within individual view rows, panels, etc.) we display a
  // message to discourage and prevent it's use. This is due to the fact that
  // we don't have a reliable way to build the XML for these cases.
  if (!empty($instance['bundle']) && $instance['bundle'] == 'ctools') {
    return array('juicebox_formatter_notice' => array(
      '#prefix' => '<p>',
      '#markup' => t('<strong>NOTICE: The Juicebox field formatter is not fully supported within individual view rows (and other ctools contexts)</strong>. Using this setting is not recommended. For views support please use the Juicebox display style plugin.'),
      '#suffix' => '</p>',
    ));
  }
  $form = array();
  // Get available title and caption sources.
  $text_sources = JuiceboxConnectorField::confGetTextSources($instance);
  // Get available image style presets
  $presets = image_style_options(FALSE);
  $settings = $instance['display'][$view_mode]['settings'];
  // Get the common form elements.
  $form = JuiceboxConnector::confBaseForm($form, $settings);
  // Add the field-formatter-specific elements.
  $form['image_style'] = array(
    '#type' => 'select',
    '#title' => t('Main Image Style'),
    '#default_value' => $settings['image_style'],
    '#description' => t('The style formatter for the main image.'),
    '#options' => $presets,
    '#empty_option' => t('None (original image)'),
  );
  $form['thumb_style'] = array(
    '#type' => 'select',
    '#title' => t('Thumbnail Style'),
    '#default_value' => $settings['thumb_style'],
    '#description' => t('The style formatter for the thumbnail.'),
    '#options' => $presets,
    '#empty_option' => t('None (original image)'),
  );
  $form['caption_source'] = array(
    '#type' => 'select',
    '#title' => t('Caption Source'),
    '#default_value' => $settings['caption_source'],
    '#description' => t('The image value that should be used for the caption.'),
    '#options' => $text_sources,
    '#empty_option' => t('No caption'),
  );
  $form['title_source'] = array(
    '#type' => 'select',
    '#title' => t('Title Source'),
    '#default_value' => $settings['title_source'],
    '#description' => t('The image value that should be used for the title.'),
    '#options' => $text_sources,
    '#empty_option' => t('No title'),
  );
  return $form;
}


/**
 * Implements hook_field_formatter_view().
 *
 * This is where the Juicebox embed code is built for the field formatter.
 */
function juicebox_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  // If there are no images, don't do anything else.
  if (empty($items)) {
    return;
  }
  $field_name = $instance['field_name'];
  $entity_type_info = entity_get_info($entity_type);
  $entity_id = $entity->{$entity_type_info['entity keys']['id']};
  // We need to get the display name to pass as part of our XML path. Though
  // we have access to the actaul $display array, it does not look like we
  // have access to the actaul display NAME in this scope. We do have access to
  // a list of ALL displays in $instanace though, so iterate though them to
  // find a match to the settings in $display.
  $display_name = 'default';
  foreach ($instance['display'] as $display_key => $display_data) {
    if ($display['settings'] == $display_data['settings']) {
      $display_name = $display_key;
    }
  }
  $settings = $instance['display'][$display_name]['settings'];
  // Generate xml path details.
  $xml_path = 'juicebox/xml/field/' . $entity_type . '/' . $entity_id . '/' . $field_name . '/' . $display_name;
  $xml_args = explode('/', $xml_path); 
  // Instantiate and build the Juicebox gallery.
  try {
    $data = array('items' => $items, 'settings' => $display['settings']);
    $juicebox = juicebox($xml_args, $data);
    // For some reason core does not test field access until AFTER this hook.
    // Because of this we run our own (duplicate) field access test here to
    // prevent unneeded logic from running if the output will be hidden. Note
    // that by this point we know that entity access is already granted.
    $juicebox->entityAccess = TRUE;
    if ($juicebox->access()) {
      // Build the gallery.
      $juicebox->build();
      $element[0] = array('#markup' => $juicebox->renderEmbed($xml_path, $settings));
    }
  }
  catch (Exception $e) {
    $message = 'Exception building Juicebox embed code: !message in %function (line %line of %file).';
    watchdog_exception('juicebox', $e, $message);
  }
  return $element;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function juicebox_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $settings_display = array();
  // Image style setting.
  if (!empty($settings['image_style'])) {
    $style = $settings['image_style'];
  }
  else {
    $style = t('Original Image');
  }
  $settings_display[] = t("Image style: @style", array('@style' => $style));
  // Thumb style setting.
  if (!empty($settings['thumb_style'])) {
    $style = $settings['thumb_style'];
  }
  else {
    $style = t('Original Image');
  }
  $settings_display[] = t("Thumbnail style: @style", array('@style' => $style));
  // Define display options for caption and title source.
  $text_sources = JuiceboxConnectorField::confGetTextSources($instance);
  // Caption source setting.
  if (!empty($text_sources[$settings['caption_source']])) {
    $source = $text_sources[$settings['caption_source']];
  }
  else {
    $source = t('None');
  }
  $settings_display[] = t("Caption source: @source", array('@source' => $source));
  // Title source setting.
  if (!empty($text_sources[$settings['title_source']])) {
    $source = $text_sources[$settings['title_source']];
  }
  else {
    $source = t('None');
  }
  $settings_display[] = t("Title source: @source", array('@source' => $source));
  // Add-in a note about the additional fieldsets.
  $settings_display[] = t("Additional Juicebox library configuration options may also be set.");
  $summary = implode('<br />', $settings_display);
  return $summary;
}
