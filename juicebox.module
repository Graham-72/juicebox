<?php


/**
 * @file
 * Provides Drupal integration with the Juicebox library. This file contains
 * the relevant Drupal hook implementations and callbacks.
 */


/**
 * Implements hook_menu().
 */
function juicebox_menu() {
  $items = array();
  // Add menu item that produces the "config.xml" data that is linked to a
  // specific gallery.
  $items['juicebox/xml/%'] = array(
    'title' => 'Juicebox XML from view',
    'description' => 'Deliver configuration XML for a Juicebox gallery.',
    'page callback' => 'juicebox_page_xml',
    'page arguments' => array(2),
    // For efficiency we'll check access in parallel to other logic in the
    // callback function, so we don't limit any access here.
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}


/**
 * Implements hook_theme().
 */
function juicebox_theme() {
  return array(
    // Theme hook to generate embed markup for a Juicebox gallery.
    'juicebox_embed_markup' => array(
      'variables' => array('gallery' => NULL, 'settings' => array()),
      'path' => drupal_get_path('module', 'juicebox') . '/themes',
      'file' => 'juicebox.theme.inc',
    ),
  );
}


/**
 * Implements hook_libraries_info().
 */
function juicebox_libraries_info() {
  $libraries['juicebox'] = array(
    'name' => 'Juicebox',
    'vendor url' => 'http://www.juicebox.net/',
    'download url' => 'http://www.juicebox.net/download/',
    'version arguments' => array(
      'file' => 'juicebox.js',
      'pattern' => '/Juicebox.([a-zA-Z]+[0-9\.\ -]+)/',
      'lines' => 5,
    ),
    'files' => array(
      // Note that we do not want the Juicebox library javascript to be
      // aggregated by Drupal (set preprocess option = FALSE). This is because
      // some supporting library CSS files must be at a specific location
      // RELATIVE to to the main js file. Aggregation breaks this.
      'js' => array('juicebox.js' => array('preprocess' => FALSE)),
    ),
    'callbacks' => array(
      'info' => array('juicebox_library_info'),
      'post-detect' => array('juicebox_library_post_detect'),
    ),
  );
  return $libraries;
}


/**
 * Implements hook_views_api().
 */
function juicebox_views_api() {
  return array(
    'api' => 3.0,
  );
}


/**
 * Implements hook_views_plugin().
 */
function juicebox_views_plugins() {
  $path = drupal_get_path('module', 'juicebox');
  $plugins['style']['juicebox'] = array(
    'title' => t('Juicebox Gallery'),
    'help' => t('Display rows as a Juicebox Gallery.'),
    'handler' => 'JuiceboxViewsStylePlugin',
    'path' => $path . '/plugins',
    'uses row plugin' => FALSE,
    'uses fields' => TRUE,
    'uses options' => TRUE,
    'uses grouping' => FALSE,
    'type' => 'normal',
  );
  return $plugins;
}


/**
 * Instantiate a Juicebox connector object along with its dependencies.
 * 
 * @param array $xml_path_args
 *   An indexed array of XML path arguments that describe this gallery (and
 *   make up its XML URL). This information uniquely identifies the gallery and
 *   contains all the descriptive data needed to (re)build it.
 * @param mixed $data
 *   (Optional) Loaded Drupal data that the gallery can be built from. When
 *   the embed code is being generated for a Drupal display formatter this data
 *   will typically be available already. However when building the XML this
 *   will be NULL, and we will need to be load it ourselves (based on the XML
 *   args) after the objects are instantiated.
 * @return object
 *   A new Juicebox plugin object that contains an empty Juicebox gallery
 *   object.
 */
function juicebox($xml_path_args, $data = NULL, $xml = FALSE) {
  // The XML args may be passed as a full set of path args. If so we can
  // drop some args that are only used for menu routing.
  if ($xml_path_args[0] == 'juicebox' && $xml_path_args[1] == 'xml') {
    $xml_path_args = array_slice($xml_path_args, 2);
  }
  // Calculate the gallery ID.
  $id = '';
  foreach ($xml_path_args as $arg) {
    $id .= $arg . '-';
  }
  $id = trim($id, '- ');
  // The type should match the first argument.
  $type = $xml_path_args[0];
  // Get the library data. We do this early (before instantiating) as the lib
  // details should be allowed to impact which classes are used.
  $library = juicebox_detect_library();
  // Calculate the connector classes that are supported directly by this module.
  $classes = array('connector_plugin' => '', 'gallery' => 'JuiceboxGallery');
  switch ($type) {
    case 'field':
      $classes['plugin_class'] = 'JuiceboxConnectorField';
      break;
    case 'view':
      $classes['plugin_class'] = 'JuiceboxConnectorViewsStyle';
      break;
  }
  // Allow other modules to alter the classes that will be used.
  $context = array('data' => $data, 'library' => $library);
  drupal_alter('juicebox_classes', $classes, $xml_path_args, $context);
  // Instantiate the Juicebox gallery object.
  $gallery = new $classes['gallery']($id);
  // Instantiate the Juicebox connector object.
  $juicebox = new $classes['plugin_class']($xml_path_args, $data, $gallery, $library);
  if (is_object($juicebox)) {
    return $juicebox;
  }
  return NULL;
}


/**
 * Get/detect the details of a Juicebox javascript library without loading it.
 * 
 * This is essentially a wrapper for libraries_detect() with some caching added.
 * It also allows library info to be fetched independently from the currently
 * loaded version if needed (e.g. to accomodate XML requests that don't come
 * from this site).
 * 
 * @param boolean $force_local
 *   Whether-or-not to force detection of the LOCALLY installed Juicebox library
 *   details. If FALSE Libraries API detection may be bypased if library version
 *   details can be detected through the URL.
 * @param boolean $reset
 *   Whether-or-not to bypass and reset any DB caching information for the
 *   library details.
 * @return array
 *   An associative array of the library information.
 */
function juicebox_detect_library($force_local = FALSE, $reset = FALSE) {
  // We use our own static cache for this. Libraries API detection has a static
  // cache, but as we may be bypassing full local detection in certain
  // situations, we can't always use it.
  $library = &drupal_static(__FUNCTION__, array());
  if (!$library) {
    // See if we have been passed version details in the URL. If so we bypass
    // local detection and build our own libraries array.
    $query = drupal_get_query_parameters();
    if (!empty($query['jb-version']) && !$force_local) {
      $version_number = check_plain($query['jb-version']);
      if (!empty($query['jb-pro'])) {
        $library['pro'] = TRUE;
        $version = 'Pro';
      }
      else {
        $version = 'Lite';
      }
      $library['version'] = $version . ' ' . $version_number;
      juicebox_library_post_detect($library);
    }
    // Otherwise we just use the Libraries API to detect the local lib.
    else {
      // We maintain our own DB cache here because libraries_detect() does not
      // have one. libaries_load() has one, but we don't want to be actually
      // loading the library here.
      $library = cache_get('local_juicebox_library', 'cache');
      if ($library && !$reset) {
        $library = $library->data;
      }
      else {
        $library = libraries_detect('juicebox');
        cache_set('local_juicebox_library', $library, 'cache');
      }
    }
  }
  return $library;
}


/**
 * Menu callback: generate Juicebox XML.
 *
 * Note that this callback directly sets page headers and prints the XML result
 * (if one can successfully be rendered).
 *
 * @see juicebox_menu()
 */
function juicebox_page_xml() {
  $args = func_get_args();
  try {
    $juicebox = juicebox($args, NULL, TRUE);
    $juicebox->load();
    if (!$juicebox->access()) {
      return MENU_ACCESS_DENIED;
    }
    // Build the Juicebox gallery data.
    $juicebox->build();
    $xml = $juicebox->gallery->getXML();
  }
  catch (Exception $e) {
    $message = 'Exception building Juicebox XML: !message in %function (line %line of %file).';
    watchdog_exception('juicebox', $e, $message);
    return MENU_NOT_FOUND;
  } 
  drupal_add_http_header('Content-Type', 'text/xml');
  // Bypass all themeing but still return (don't die) so that
  // drupal_page_footer() is called.
  print($xml);
  return NULL;
}


/**
 * Libraries API Info Callback
 * 
 * Add baseline variables to a Juicebox library array that are not version
 * specific but should always be defined. These values are generic to all
 * Juicebox libraries and may be referenced even when the local library info
 * cannot be loaded or is not used.
 * 
 * @see juicebox_libraries_info().
 */
function juicebox_library_info(&$library) {
  $library['disallowed_conf'] = array();
  $library['compatible_mimetypes'] = array('image/gif', 'image/jpeg', 'image/png');
}


/**
 * Libraries API Post-Detect Callback
 * 
 * Add detailed variables to a Juicebox library array after the version info can
 * be detected.
 * 
 * @see juicebox_libraries_info().
 */
function juicebox_library_post_detect(&$library) {
  $pro = FALSE;
  $disallowed_conf = array();
  if (!empty($library['version'])) {
    // Check if this is a Pro version.
    if (stripos($library['version'], "Pro") !== FALSE) {
      $pro = TRUE;
    }
    // Get numeric part of the version statement.
    $version_number = 0;
    $matches = array();
    preg_match("/[0-9\.]+[^\.]$/u", $library['version'], $matches);
    if (!empty($matches[0])) {
      $version_number = $matches[0];
    }
    // Some options are not available as LITE options before v1.3.
    if (!$pro && version_compare($version_number, '1.3', '<')) {
      $disallowed_conf = array_merge($disallowed_conf, array('jlib_textColor', 'jlib_thumbFrameColor', 'jlib_useFullscreenExpand', 'jlib_useThumbDots'));
    }
  }
  $library['pro'] = $pro;
  $library['disallowed_conf'] = $disallowed_conf;
}


/**
 * Form validation callback: validate width/height inputs.
 */
function juicebox_element_validate_dimension($element, &$form_state, $form) {
  if (!preg_match('/^[0-9]+?(%|px|em|in|cm|mm|ex|pt|pc)$/u', $element['#value'])) {
    form_error($element, t('Please ensure that you width and height values are entered in a standard numeric format (such as <strong>100%</strong> or <strong>300px</strong>).'));
  }
}


/**
 * Form validation callback: validate Juicebox configuration options.
 */
function juicebox_element_validate_config($element, &$form_state, $form) {
  // We are looking for input in the format of: optionName="optionValue".
  // The check here is not too strict, it is just meant to catch general
  // formatting issues.
  $custom_options = explode("\n", $element['#value']);
  foreach ($custom_options as $key => $option) {
    $option = trim($option);
    $line_number = $key + 1;
    if (!empty($option) && !preg_match('/^[A-Za-z0-9]+?="[^"]+?"$/u', $option)) {
      form_error($element, t('One of your manual configuration options appears to be formatted incorrectly. Please check line @line of this field and ensure that you are using the format <strong>optionName="optionValue"</strong> and that all spaces have been removed.', array('@line' => $line_number)));
    }
  }
}


/**
 * Form pre-render callback: visually render fieldsets without affecting
 * tree-based variable storage.
 * 
 * This technique/code is taken almost directly from the Views module in
 * views_ui_pre_render_add_fieldset_markup()
 */
function juicebox_form_pre_render_fieldsets($form) {
  foreach (element_children($form) as $key) {
    $element = $form[$key];
    // In our form builder functions, we added an arbitrary #jb_fieldset
    // property to any element that belongs in a fieldset. If this form element
    // has that property, move it into its fieldset.
    if (isset($element['#jb_fieldset']) && isset($form[$element['#jb_fieldset']])) {
      $form[$element['#jb_fieldset']][$key] = $element;
      // Remove the original element this duplicates.
      unset($form[$key]);
    }
  }
  return $form;
}


/**
 * Implements hook_field_formatter_info().
 *
 * Add juicebox_formatter formatter.
 */
function juicebox_field_formatter_info() {
  // Get the base settings.
  $base_settings = JuiceboxConnector::confBaseOptions();
  $formatters = array(
    'juicebox_formatter' => array(
      'label' => t('Juicebox Gallery'),
      'field types' => array('image', 'file'),
      'settings' => array_merge($base_settings, array(
        'image_style' => '',
        'thumb_style' => 'thumbnail',
        'caption_source' => 'alt',
        'title_source' => 'title',
      )),
    ),
  );
  return $formatters;
}


/**
 * Implements hook_field_formatter_settings_form().
 */
function juicebox_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  // If this formatter is being used outside the context of a normal field
  // display (e.g. within individual view rows, panels, etc.) we display a
  // message to discourage and prevent it's use. This is due to the fact that
  // we don't have a reliable way to build the XML for these cases.
  if (!empty($instance['bundle']) && $instance['bundle'] == 'ctools') {
    return array('juicebox_formatter_notice' => array(
      '#prefix' => '<p>',
      '#markup' => t('<strong>NOTICE: The Juicebox field formatter is not fully supported within individual view rows (and other ctools contexts)</strong>. Using this setting is not recommended. For views support please use the Juicebox display style plugin.'),
      '#suffix' => '</p>',
    ));
  }
  $form = array();
  // Get available title and caption sources.
  $text_sources = _juicebox_field_formatter_get_text_sources($instance);
  // Get available image style presets
  $presets = image_style_options(FALSE);
  $settings = $instance['display'][$view_mode]['settings'];
  // Get the common form elements.
  $form = JuiceboxConnector::confBaseForm($form, $settings);
  // Add the field-formatter-specific elements.
  $form['image_style'] = array(
    '#type' => 'select',
    '#title' => t('Main Image Style'),
    '#default_value' => $settings['image_style'],
    '#description' => t('The style formatter for the main image.'),
    '#options' => $presets,
    '#empty_option' => t('None (original image)'),
  );
  $form['thumb_style'] = array(
    '#type' => 'select',
    '#title' => t('Thumbnail Style'),
    '#default_value' => $settings['thumb_style'],
    '#description' => t('The style formatter for the thumbnail.'),
    '#options' => $presets,
    '#empty_option' => t('None (original image)'),
  );
  $form['caption_source'] = array(
    '#type' => 'select',
    '#title' => t('Caption Source'),
    '#default_value' => $settings['caption_source'],
    '#description' => t('The image value that should be used for the caption.'),
    '#options' => $text_sources,
    '#empty_option' => t('No caption'),
  );
  $form['title_source'] = array(
    '#type' => 'select',
    '#title' => t('Title Source'),
    '#default_value' => $settings['title_source'],
    '#description' => t('The image value that should be used for the title.'),
    '#options' => $text_sources,
    '#empty_option' => t('No title'),
  );
  return $form;
}


/**
 * Implements hook_field_formatter_view().
 *
 * This is where the Juicebox embed code is built for the field formatter.
 */
function juicebox_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  // If there are no images, don't do anything else.
  if (empty($items)) {
    return;
  }
  $field_name = $instance['field_name'];
  $entity_type_info = entity_get_info($entity_type);
  $entity_id = $entity->{$entity_type_info['entity keys']['id']};
  // We need to get the display name to pass as part of our XML path. Though
  // we have access to the actaul $display array, it does not look like we
  // have access to the actaul display NAME in this scope. We do have access to
  // a list of ALL displays in $instanace though, so iterate though them to
  // find a match to the settings in $display.
  $display_name = 'default';
  foreach ($instance['display'] as $display_key => $display_data) {
    if ($display['settings'] == $display_data['settings']) {
      $display_name = $display_key;
    }
  }
  $settings = $instance['display'][$display_name]['settings'];
  // Generate xml path details.
  $xml_path = 'juicebox/xml/field/' . $entity_type . '/' . $entity_id . '/' . $field_name . '/' . $display_name;
  $xml_args = explode('/', $xml_path);
  
  // Instantiate and build the Juicebox gallery.
  try {
    $data = array('items' => $items, 'settings' => $display['settings']);
    $juicebox = juicebox($xml_args, $data);
    // For some reason core does not test field access until AFTER this hook.
    // Because of this we run our own (duplicate) field access test here to
    // prevent unneeded logic from running if the output will be hidden. Note
    // that by this point we know that entity access is already granted.
    $juicebox->entityAccess = TRUE;
    if ($juicebox->access()) {
      // Build the gallery.
      $juicebox->build();
      // Get the full XML url.
      $xml_query = array_merge(array('checksum' => $juicebox->gallery->getChecksum()), drupal_get_query_parameters());
      $xml_url = url($xml_path, array('query' => $xml_query));
      // Load the juicebox javascript library and gallery-specific javascript.
      libraries_load('juicebox');
      drupal_add_js($juicebox->gallery->getJavascript($xml_url), 'inline');
      $element[0] = array('#markup' => $juicebox->renderEmbed($settings));
    }
  }
  catch (Exception $e) {
    $message = 'Exception building Juicebox embed code: !message in %function (line %line of %file).';
    watchdog_exception('juicebox', $e, $message);
  }
  return $element;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function juicebox_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];
  $settings_display = array();
  // Image style setting.
  if (!empty($settings['image_style'])) {
    $style = $settings['image_style'];
  }
  else {
    $style = t('Original Image');
  }
  $settings_display[] = t("Image style: @style", array('@style' => $style));
  // Thumb style setting.
  if (!empty($settings['thumb_style'])) {
    $style = $settings['thumb_style'];
  }
  else {
    $style = t('Original Image');
  }
  $settings_display[] = t("Thumbnail style: @style", array('@style' => $style));
  // Define display options for caption and title source.
  $text_sources = _juicebox_field_formatter_get_text_sources($instance);
  // Caption source setting.
  if (!empty($text_sources[$settings['caption_source']])) {
    $source = $text_sources[$settings['caption_source']];
  }
  else {
    $source = t('None');
  }
  $settings_display[] = t("Caption source: @source", array('@source' => $source));
  // Title source setting.
  if (!empty($text_sources[$settings['title_source']])) {
    $source = $text_sources[$settings['title_source']];
  }
  else {
    $source = t('None');
  }
  $settings_display[] = t("Title source: @source", array('@source' => $source));
  // Add-in a note about the additional fieldsets.
  $settings_display[] = t("Additional Juicebox library configuration options may also be set.");
  $summary = implode('<br />', $settings_display);
  return $summary;
}


/**
 * Utility to fetch the title and caption source options for field-based
 * galleries (primarily for File Entity and Media module support).
 *
 * @param array $instance
 *   An associative array containing the Drupal field instance information for
 *   a Juicebox field.
 * @return array
 *   An associative array representing the key => label pairs for each title and
 *   caption source option. Each key will match a keyed value on the image
 *   source array when the gallery is built.
 */
function _juicebox_field_formatter_get_text_sources($instance) {
  // If this is a standard image field, using the image widget, we can use core
  // image "alt" and "title" values if they are active.
  if (!empty($instance['widget']['module']) && $instance['widget']['module'] == 'image') {
    if (!empty($instance['settings']['alt_field'])) {
      $text_source_options['alt'] = t('Image - Alt text (processed by fallback text format)');
    }
    if (!empty($instance['settings']['title_field'])) {
      $text_source_options['title'] = t('Image - Title text (processed by fallback text format)');
    }
  }
  // If file entity is installed we can use fields attached to the "image" file
  // entity.
  if (module_exists('file_entity')) {
    // Get the fields that are available on the image file type.
    $image_fields = field_info_instances('file', 'image');
    foreach ($image_fields as $image_field_name => $image_field) {
      // Only text-based fields should be options.
      if (!empty($image_field['widget']['module']) && $image_field['widget']['module'] == 'text') {
        $text_source_options[$image_field_name] = t('File Entity Image - @label', array('@label' => $image_field['label']));
      }
    }
  }
  return $text_source_options;
}


/**
 * Utility to fetch a field value from an entity field (primarily for Media
 * module support).
 *
 * @param int $fid
 *   The id of a file that can be represented as a file entity. This id will
 *   match the file entity id.
 * @param string $field_name
 *   The name of the field to fetch from the file entity.
 * @return mixed
 *   The safe value for the requested field. For multiple-value fields only the
 *   first value will be returned. Returns NULL if no value can be found.
 */
function _juicebox_get_field_value_from_file_entity($fid, $field_name) {
  // We depend on the entity cache for performance when loading the file entity.
  // If the passed fid does in fact represent a file entity then there
  // is a very good chance it's been loaded already by the time this function is
  // called.
  $file_entity = entity_load('file', array($fid));
  if (!empty($file_entity[$fid])) {
    $field = field_get_items('file', $file_entity[$fid], $field_name);
    if (!empty($field[0]['safe_value'])) {
      return $field[0]['safe_value'];
    }
  }
  return NULL;
}


/**
 * Helper to detect if a given file item is not compatible with Juicebox, and
 * define an alternative file to display if so.
 *
 * @param array $item
 *   An associative array containing all file entity properties for the file to
 *   check.
 * @param array $library
 *   An associative array containing the library information that corresponds
 *   to the Juicebox javascript library that will be used for the display.
 * @return string
 *   If an incompatible file is detected an alternative image path is returned,
 *   otherwise returns NULL.
 */
function _juicebox_incompatible_file_alternative($item, $library) {
  if (!empty($library['compatible_mimetypes']) && !in_array($item['filemime'], $library['compatible_mimetypes'])) {
    $icon_dir = drupal_get_path('module', 'juicebox') . '/images/mimetypes';
    $icon_path = file_icon_path(file_load($item['fid']), $icon_dir);
    if ($icon_path) {
      return url($icon_path);
    }
    return url($icon_dir . '/image-x-generic.png');
  }
  return NULL;
}